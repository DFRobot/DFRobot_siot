'''# file siot.py# brief         download into mpython and run the demo# Copyright     Copyright (c) 2010 DFRobot Co.Ltd (http://www.dfrobot.com)# licence       The MIT License (MIT)# author        [LuoYufeng](yufeng.luo@dfrobot.com)# version       V1.0# date          2019-10-8'''import usocket as socketimport ustruct as structfrom machine import Timer#from ubinascii import hexlifyclass MQTTException(Exception):    passtim = None_sock = None_pid = 0_cb = Nonelw_topic = Nonelw_msg = Nonelw_qos = 0lw_retain = Falsedef init(client_id, server, port=0, user=None, password=None, keepalive=0,ssl=False, ssl_params={}):  global _client_id, _addr, _ssl, _ssl_params, _user, _pswd, _keepalive  if port == 0:    port = 8883 if ssl else 1883  _client_id = client_id  _addr = socket.getaddrinfo(server, port)[0][-1]  _ssl = ssl  _ssl_params = ssl_params  _user = user  _pswd = password  _keepalive = keepalivedef _send_str(s):  global _sock  _sock.write(struct.pack("!H", len(s)))  _sock.write(s)def _recv_len():  global _sock  n = 0  sh = 0  while 1:    b = _sock.read(1)[0]    n |= (b & 0x7f) << sh    if not b & 0x80:      return n    sh += 7    def set_callback(f):  global _cb  _cb = fdef subscribe(topic, callback):  global _cb  _cb = callback  getsubscribe(topic)def loop():  global tim  if tim !=None:    tim.deinit()  tim = Timer(1)  tim.init(period=50,mode=Timer.PERIODIC, callback=check_msg)def set_last_will(topic, msg, retain=False, qos=0):  global lw_topic, lw_msg, lw_qos, lw_retain  assert 0 <= qos <= 2  assert topic  lw_topic = topic  lw_msg = msg  lw_qos = qos  lw_retain = retaindef connect(clean_session=True):  global _sock, _ssl, _user, _keepalive, lw_topic  _sock = socket.socket()  _sock.connect(_addr)  if _ssl:    import ussl    _sock = ussl.wrap_socket(_sock, **_ssl_params)  msg = bytearray(b"\x10\0\0\x04MQTT\x04\x02\0\0")  msg[1] = 10 + 2 + len(_client_id)  msg[9] = clean_session << 1  if _user is not None:    msg[1] += 2 + len(_user) + 2 + len(_pswd)    msg[9] |= 0xC0  if _keepalive:    assert _keepalive < 65536    msg[10] |= _keepalive >> 8    msg[11] |= _keepalive & 0x00FF  if lw_topic:    msg[1] += 2 + len(lw_topic) + 2 + len(lw_msg)    msg[9] |= 0x4 | (lw_qos & 0x1) << 3 | (lw_qos & 0x2) << 3    msg[9] |= lw_retain << 5  _sock.write(msg)  #print(hex(len(msg)), hexlify(msg, ":"))  _send_str(_client_id)  if lw_topic:    _send_str(lw_topic)    _send_str(lw_msg)  if _user is not None:    _send_str(_user)    _send_str(_pswd)  resp = _sock.read(4)  assert resp[0] == 0x20 and resp[1] == 0x02  if resp[3] != 0:    raise MQTTException(resp[3])  return resp[2] & 1def stop():  global _sock, tim  _sock.write(b"\xe0\0")  _sock.close()  if tim !=None:    tim.deinit()def ping():  global _sock  _sock.write(b"\xc0\0")def publish(topic, msg, retain=False, qos=0):  global _sock, _pid  pkt = bytearray(b"\x30\0\0\0")  pkt[0] |= qos << 1 | retain  sz = 2 + len(topic) + len(msg)  if qos > 0:    sz += 2  assert sz < 2097152  i = 1  while sz > 0x7f:    pkt[i] = (sz & 0x7f) | 0x80    sz >>= 7    i += 1  pkt[i] = sz  #print(hex(len(pkt)), hexlify(pkt, ":"))  _sock.write(pkt, i + 1)  _send_str(topic)  if qos > 0:    _pid += 1    pid = _pid    struct.pack_into("!H", pkt, 0, pid)    _sock.write(pkt, 2)  _sock.write(msg)  if qos == 1:    while 1:      op = wait_msg()       if op == 0x40:        sz = _sock.read(1)        assert sz == b"\x02"        rcv_pid = _sock.read(2)        rcv_pid = rcv_pid[0] << 8 | rcv_pid[1]        if pid == rcv_pid:          return  elif qos == 2:    assert 0def getsubscribe(topic, qos=0):  global _sock, _pid  assert _cb is not None, "getsubscribe callback is not set"  pkt = bytearray(b"\x82\0\0\0")  _pid += 1  struct.pack_into("!BH", pkt, 1, 2 + 2 + len(topic) + 1, _pid)  #print(hex(len(pkt)), hexlify(pkt, ":"))  _sock.write(pkt)  _send_str(topic)  _sock.write(qos.to_bytes(1, "little"))  while 1:    op = wait_msg()    if op == 0x90:      resp = _sock.read(4)      #print(resp)      assert resp[1] == pkt[2] and resp[2] == pkt[3]      if resp[3] == 0x80:        raise MQTTException(resp[3])      return# Wait for a single incoming MQTT message and process it.# Subscribed messages are delivered to a callback previously# set by .set_callback() method. Other (internal) MQTT# messages processed internally.def wait_msg():  global _sock  res = _sock.read(1)  _sock.setblocking(True)  if res is None:    return None  if res == b"":    raise OSError(-1)  if res == b"\xd0":  # PINGRESP    sz = _sock.read(1)[0]    assert sz == 0    return None  op = res[0]  if op & 0xf0 != 0x30:    return op  sz = _recv_len()  topic_len = _sock.read(2)  topic_len = (topic_len[0] << 8) | topic_len[1]  topic = _sock.read(topic_len)  sz -= topic_len + 2  if op & 6:    pid = _sock.read(2)    pid = pid[0] << 8 | pid[1]    sz -= 2  msg = _sock.read(sz)  _cb(topic, msg)  if op & 6 == 2:    pkt = bytearray(b"\x40\x02\0\0")    struct.pack_into("!H", pkt, 2, pid)    _sock.write(pkt)  elif op & 6 == 4:    assert 0# Checks whether a pending message from server is available.# If not, returns immediately with None. Otherwise, does# the same processing as wait_msg.def check_msg(msg = ""):  global _sock  _sock.setblocking(False)  return wait_msg()